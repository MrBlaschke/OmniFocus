use AppleScript version "2.4" -- Yosemite (10.10) or lateruse scripting additionsuse application "OmniFocus"property NSString : a reference to current application's NSStringproperty NSRegularExpressionSearch : a reference to 1024use framework "Foundation"property creator : "Brandon Pittman"property thanks : "Thank you for downloading my OmniFocus library."property doc : a reference to default documenton selectedItems()	set theWindow to front document window of front document of application "OmniFocus"	set theTasks to selected trees of content of theWindow	set theValues to {}	repeat with n in theTasks		set end of theValues to value of n	end repeat	theValuesend selectedItemson parse(transportText)	parse tasks into default document with transport text transportTextend parseon findContext(contextName)	first flattened context of default document whose name is contextName and hidden is falseend findContexton findProject(projectName)	first flattened project of default document whose name is projectName and completed is falseend findProjecton findFolder(folderName)	first flattened folder of default document whose name is folderName and hidden is falseend findFolderon findTask(taskName)	first flattened task of default document whose name is taskName and completed is falseend findTaskon findAllContexts(contextName)	every context of default document whose name is contextName and hidden is falseend findAllContextson findAllProjects(projectName)	every flattened project of default document whose name is contextName and completed is falseend findAllProjectson findAllFolders(folderName)	every flattened folder of default document whose name is folderName and hidden is falseend findAllFolderson findAllTasks(taskName)	every flattened task of default document whose name is taskName and completed is falseend findAllTaskson allTasks()	every flattened task of default document whose completed is falseend allTaskson allProjects()	every flattened project of default document whose completed is falseend allProjectson allContexts()	every flattened context of default document whose hidden is falseend allContextson setDue(input, dueDate)	if class of input is not list then		set due date of input to dueDate	else if class of input is list then		repeat with _input in input			set due date of _input to dueDate		end repeat	end ifend setDueon setDefer(input, deferDate)	if class of input is not list then		set defer date of input to deferDate	else if class of input is list then		repeat with _input in input			set defer date of _input to deferDate		end repeat	end ifend setDeferon setContainer(input, projectInput)	if class of projectInput is text then		set theProject to findProject(projectInput)	else		set theProject to projectInput	end if	if class of input is not list then		set assigned container of input to theProject	else if class of input is list then		repeat with _input in input			set assigned container of _input to theProject		end repeat	end ifend setContaineron setContext(input, contextInput)	if class of contextInput is text then		set theContext to findContext(contextInput)	else		set theContext to contextInput	end if	if class of input is not list then		set context of input to theContext	else if class of input is list then		repeat with _input in input			set context of _input to theContext		end repeat	end ifend setContexton inboxTasks()	every inbox task of default documentend inboxTaskson namePrepend(input, prependString)	if class of input is not list then		set name of input to prependString & " " & name of input	else if class of input is list then		repeat with _input in input			set name of _input to prependString & " " & name of _input		end repeat	end ifend namePrependon nameAppend(input, appendString)	if class of input is not list then		set name of input to name of input & " " & appendString	else if class of input is list then		repeat with _input in input			set name of _input to name of _input & " " & appendString		end repeat	end ifend nameAppendon setComplete(input, flag)	if class of input is not list then		set completed of input to flag	else if class of input is list then		repeat with _input in input			set completed of _input to flag		end repeat	end ifend setCompleteon setSequential(input, flag)	if class of input is not list then		set sequential of input to flag	else if class of input is list then		repeat with _input in input			set sequential of _input to flag		end repeat	end ifend setSequentialon toggleSequential(input)	if class of input is not list then		set sequential of input to not (sequential of input)	else if class of input is list then		repeat with _input in input			set sequential of _input to not (sequential of _input)		end repeat	end ifend toggleSequential# Creating Flow with OmniFocuson openPerspective(perspectiveName)	set perspective name of front window of application "OmniFocus" to perspectiveNameend openPerspectiveon inboxCount()	count inbox tasks of default documentend inboxCounton errandsCount()	available task count of findContext("Errands")end errandsCounton routineCount()	set taskCount to 0	set flattenedProjects to flattened projects of findFolder("Routine")	repeat with flattenedProject in flattenedProjects		set taskCount to taskCount + (number of available tasks of flattenedProject)	end repeatend routineCounton landAndSeaCount()	number of available tasks of findProject("Land & Sea")end landAndSeaCounton computerName()	do shell script "scutil --get ComputerName"end computerName# Repetition ruleson setRepeat(input, repetitionRule)	if class of input is not list then		set repetition rule of input to repetitionRule	else if class of input is list then		repeat with _input in input			set repetition rule of _input to repetitionRule		end repeat	end ifend setRepeaton deferDaily(input)	setRepeat(input, {recurrence:"FREQ=DAILY;INTERVAL=1", repetition method:start after completion})end deferDailyon deferWeekly(input)	setRepeat(input, {recurrence:"FREQ=WEEKLY;INTERVAL=1", repetition method:start after completion})end deferWeeklyon deferMonthly(input)	setRepeat(input, {recurrence:"FREQ=MONTHLY;INTERVAL=1", repetition method:start after completion})end deferMonthlyon repeatDaily(input)	setRepeat(input, {recurrence:"FREQ=DAILY;INTERVAL=1", repetition method:fixed repetition})end repeatDailyon repeatWeekly(input)	setRepeat(input, {recurrence:"FREQ=WEEKLY;INTERVAL=1", repetition method:fixed repetition})end repeatWeeklyon repeatMonthly(input)	setRepeat(input, {recurrence:"FREQ=MONTHLY;INTERVAL=1", repetition method:fixed repetition})end repeatMonthly# Clear properties, etc.on clearRepeat(input)	setRepeat(input, missing value)end clearRepeaton clearContext(input)	setContext(input, missing value)end clearContexton clearContainer(input)	setContainer(input, missing value)end clearContaineron clearDefer(input)	setDefer(input, missing value)end clearDeferon showAbout()	tell application "System Events"		tell process "OmniFocus"			click menu item "About OmniFocus" of menu "OmniFocus" of menu bar item "OmniFocus" of menu bar 1		end tell	end tellend showAbouton setOnHold(input)	repeat with i in input		if class of i is project then set status of i to on hold	end repeatend setOnHoldon setActive(input)	repeat with i in input		if class of i is project then set status of i to active	end repeatend setActive# Colonize/Decolonizeon titlecase(sourceString)	((NSString's stringWithString:sourceString)'s capitalizedString()) as textend titlecaseon downcase(sourceString)	((NSString's stringWithString:sourceString)'s lowercaseString()) as textend downcaseon toggleColon(input)	if class of input is not list then		set textProperties to {}		set theText to text of (get name of input)		set firstWord to first word of theText		set firstWordPlusOne to text 1 thru ((length of firstWord) + 1) of theText				if text -1 of firstWordPlusOne is ":" then			removeColon(input)		else			addColon(input)		end if	else if class of input is list then		repeat with _input in input			set textProperties to {}			set theText to text of (get name of _input)			set firstWord to first word of theText			set firstWordPlusOne to text 1 thru ((length of firstWord) + 1) of theText						if text -1 of firstWordPlusOne is ":" then				removeColon(_input)			else				addColon(_input)			end if		end repeat	end ifend toggleColonon addColon(input)	set textProperties to {}	set theText to text of (get name of input)	set firstWord to first word of theText	set firstWordPlusOne to text 1 thru ((length of firstWord) + 1) of theText		if text -1 of firstWordPlusOne is not ":" then		set textProperties to textProperties & {theRest:text -1 thru ((length of firstWord) + 2) of theText}		set name of input to titlecase(firstWord) & ": " & downcase(theRest of textProperties)	end ifend addColonon removeColon(input)	set textProperties to {}	set theText to text of (get name of input)	set firstWord to first word of theText	set firstWordPlusOne to text 1 thru ((length of firstWord) + 1) of theText		if text -1 of firstWordPlusOne is ":" then		set textProperties to textProperties & {theRest:text -1 thru ((length of firstWord) + 3) of theText}		set name of input to titlecase(firstWord) & " " & downcase(theRest of textProperties)	end ifend removeColonon setColon(input)	if class of input is not list then		addColon(input)	else if class of input is list then		repeat with _input in input			addColon(_input)		end repeat	end ifend setColonon clearColon(input)	if class of input is not list then		removeColon(input)	else if class of input is list then		repeat with _input in input			removeColon(_input)		end repeat	end ifend clearColonon setPrefix(input, prefix)	set thePrefix to (prefix & ":")	if class of input is not list then		namePrepend(input, thePrefix)	else if class of input is list then		repeat with _input in input			namePrepend(_input, thePrefix)		end repeat	end ifend setPrefixon clearPrefix(input, prefix)	set thePrefix to (prefix & ": ?")	if class of input is not list then		set newName to replaceRegex(name of input, thePrefix, "")		set name of input to newName	else if class of input is list then		repeat with _input in input			set newName to replaceRegex(name of _input, thePrefix, "")			set name of _input to newName		end repeat	end ifend clearPrefixon clearPrefixAll(input)	set thePrefix to (".+: ?")	if class of input is not list then		set newName to replaceRegex(name of input, thePrefix, "")		set name of input to newName	else if class of input is list then		repeat with _input in input			set newName to replaceRegex(name of _input, thePrefix, "")			set name of _input to newName		end repeat	end ifend clearPrefixAllon setConsider(input)	setPrefix(input, "Consider")end setConsideron clearConsider(input)	clearPrefix(input, "Consider")end clearConsideron toggleConsider(input)	if class of input is not list then		if first word of (get name of input) is "Consider" then			clearConsider(input)		else			setConsider(input)		end if	else if class of input is list then		repeat with _input in input			if first word of (get name of _input) is "Consider" then				clearConsider(_input)			else				setConsider(_input)			end if		end repeat	end ifend toggleConsider# Needed for prefix handlerson replaceRegex(sourceString, theFind, theReplace)	set aString to NSString's stringWithString:sourceString	(aString's stringByReplacingOccurrencesOfString:theFind withString:theReplace options:NSRegularExpressionSearch range:{0, aString's |length|()}) as textend replaceRegex